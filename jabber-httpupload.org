#+TODO: TODO WIP EXTEND CLEANUP FIXME REVIEW |
#+PROPERTY: header-args :tangle yes :results silent

This file implements the HTTP Upload [[https://xmpp.org/extensions/xep-0363.html][XEP-0363]] extension.
It is separated from the jabber.org file in order to implement and test it without affecting the original implementation.

The HTTP Upload implements a way to send files (images, audio, etc.) through XMPP clients by using server space and the HTTP protocol to upload and download from it. The advantage is that the sender user does not need to be connected after sharing the file, and the receiver may be disconnected while the sender is uploading.

The procedure to send a file is the following:

1. Use Disco queries to discover if the server supports the HTTP Upload (~urn:xmpp:http:upload~ namespace).
2. Request a slot to the upload Disco item. The server will answer with a GET and PUT URL.
3. Upload the file to the HTTP server by using the PUT URL.
4. Usually, send the GET URL to the other XMPP clients to allow them to access the uploaded file.

* Headers and commentary
#+BEGIN_SRC emacs-lisp
;;; jabber-httpupload.el --- Emacs Jabber HTTP Upload Implementation -*- lexical-binding: t; -*-

;; Copyright 2021 cnngimenez
;;
;; Author: cnngimenez
;; Maintainer: cnngimenez
;; Version: 0.1.0
;; Keywords: comm
;; URL: https://github.com/cnngimenez/emacs-jabber
;; Package-Requires: ((emacs "24.1"))

;; This program is free software: you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.

;; This program is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with this program.  If not, see <https://www.gnu.org/licenses/>.


;;; Commentary:

;; 

;;; Code:
#+END_SRC

* Required libraries
#+BEGIN_SRC emacs-lisp
(require 'seq)
(require 'fsm)
(require 'jabber)
#+END_SRC

* Configuration variables

** jabber-httpupload group
#+BEGIN_SRC emacs-lisp
(defgroup 'jabber-httpupload nil "Jabber HTTP Upload Settings."
  :group 'jabber)
#+END_SRC

** jabber-httpupload-upload-function
#+BEGIN_SRC emacs-lisp
  (defcustom jabber-httpupload-upload-function #'jabber-httpupload-put-file-curl
    "The function used to upload the file.
  Some functions calls external programs such as Curl and wget, please check their
  documentation for more information."
    :group 'jabber-httpupload
    :type 'function)
#+END_SRC


* Discovering support
Disco is used to discover if HTTP Upload is supported on the server side. Two queries are used:

1. An IQ Disco items request to get all items supported by the server. 
2. For each item, an IQ Disco info request to test if the item is the Upload service.

The namespace of the HTTP Upload feature is ~urn:xmpp:http:upload:0~. This will be used on the second query to detect which item is the upload service.

For more information, see XML examples at the [[https://xmpp.org/extensions/xep-0363.html#disco][Discovering Support section of XEP-0363]].

This implementation requires an initialization step to fill the ~jabber-httpupload-support~ variable. This variable registers all connections with their HTTP Upload item. If one of the server associated to a connection does not support HTTP Upload, then it will be registered with a ~nil~ item.

** jabber-httpupload-support                                      :variable:
#+BEGIN_SRC emacs-lisp
(defvar jabber-httpupload-support nil
"An alist of jabber connections and the node with HTTP Upload support.
This is filled by the `jabber-httpupload-test-all-connections-suport'.
Each element are of the form (jabber-connection . string/nil).  If the value is
a string, it is the upload item IRI, if nil means no support.")
#+END_SRC

** jabber-httpupload-all-connections-support
#+BEGIN_SRC emacs-lisp
(defun jabber-httpupload-test-all-connections-support ()
  "Test all connections in `jabber-connections' for HTTP Upload support.
Store the results at `jabber-httpupload-support'.
If the connection is already tested, ignore it."
  (let ((connections (seq-difference jabber-connections
                                     (mapcar #'car jabber-httpupload-support))))
    (dolist (jc connections)
      (jabber-httpupload-test-connection-support jc))))
#+END_SRC

** jabber-httpupload-test-connection-support
#+BEGIN_SRC emacs-lisp
(defun jabber-httpupload-test-connection-support (jc)
  "Test if HTTP Upload is supported on the JC connection's server.
If it is supported, store the item IRI at `jabber-httpupload-support'."
  (jabber-httpupload-apply-to-items jc
                               (lambda (jc result)
                                 (jabber-httpupload-test-item-support jc (elt result 1)))))
#+END_SRC

** jabber-httpupload-test-item-support
~callback~ receives three arguments: the jabber connection, extra data and the query result. The result is a list of features supported by the server. For example, if the client receives the following IQ answer:

#+BEGIN_SRC xml
<iq from="upload.server.org" type="result" to="myjid@server.org/pc1" id="emacs-iq-24678.666.622936">
  <query xmlns="http://jabber.org/protocol/disco#info">
    <identity name="HTTP File Upload" type="file" category="store"/>
    <feature var="http://jabber.org/protocol/disco#info"/>
    <feature var="http://jabber.org/protocol/disco#items"/>
    <feature var="urn:xmpp:http:upload:0"/>
    <feature var="urn:xmpp:http:upload"/>
    <x xmlns="jabber:x:data" type="result">
      <field type="hidden" var="FORM_TYPE">
        <value>urn:xmpp:http:upload:0</value>
      </field>
      <field type="text-single" var="max-file-size">
        <value>500000</value>
      </field>
    </x>
    <x xmlns="jabber:x:data" type="result">
      <field type="hidden" var="FORM_TYPE">
        <value>urn:xmpp:http:upload</value>
      </field>
      <field type="text-single" var="max-file-size">
        <value>500000</value>
      </field>
    </x>
  </query>
</iq>
#+END_SRC

The result would be:

: ((["HTTP File Upload" "store" "file"]) ("http://jabber.org/protocol/disco#info" "http://jabber.org/protocol/disco#items" "urn:xmpp:http:upload:0" "urn:xmpp:http:upload"))

This Disco item support HTTP Upload because the ~urn:xmpp:http:upload~ namespace is in the second list.

#+BEGIN_SRC emacs-lisp
(defun jabber-httpupload-test-item-support (jc iri)
  "Test if the IRI Disco item supports HTTP Upload.
Get the Disco Info from the provided IRI at the current JC jabber connection,
if the HTTP Upload namespace feature is in the answer, store the IRI
in `jabber-httpupload-support'."
  (jabber-disco-get-info jc iri nil
                         (lambda (jc _data result)
                           (when (member "urn:xmpp:http:upload"
                                         (nth 1 result))
                             ;; This item supports HTTP Upload... register it!
                             (push (cons jc iri) jabber-httpupload-support)))
                           nil))
  #+END_SRC

** jabber-httpupload-apply-to-items
~callback~ receives three arguments: the jabber connection, extra data and the query result. The result is a list of vector with the node name, its IRI and any other properties.

For example, if the client receives the following XML:
#+BEGIN_SRC xml
  <iq from="server.org" type="result" to="myjid@server.org/pc1" id="emacs-iq-24677.56646.166389">
    <query xmlns="http://jabber.org/protocol/disco#items">
      <item jid="conference.server.org" name="MUC chats!"/>
      <item jid="upload.server.org"/>
    </query>
  </iq>
#+END_SRC

The result would be:

: (["MUC chats!" "conference.server.org" nil] [nil "upload.server.org" nil])

#+BEGIN_SRC emacs-lisp
(defun jabber-httpupload-apply-to-items (jc callback)
  "Retrieve al Disco IRIs from the server connected in JC.
Return a list of IRI strings.

JC is a jabber connection.
CALLBACK is a function that receives two arguments: Jabber connection and
the item vector."
  (let ((node (plist-get (fsm-get-state-data jc) :server)))
    (jabber-disco-get-items jc node nil
                            (lambda (jc _data result)
                              (dolist (item result)
		      (message "item: %S" item)
                                (funcall callback jc item)))
                            nil)))
#+END_SRC

** jabber-httpupload-has-support
Use this function to check if a Jabber Connection has HTTP Upload support.

#+BEGIN_SRC emacs-lisp
(defun jabber-httpupload-server-has-support (jc)
  "Check if the server has HTTP Upload support.
Return non-nil when there is support from the server.

JC is the Jabber Connection to use.
The variable `jabber-httpupload-support' is used.  To test for server support
on-line, use `jabber-httpupload-test-connection-support'."
  (seq-find (lambda (tuple)
              (and (equal jc (car tuple))
                   (cdr tuple)))
            jabber-httpupload-support))
#+END_SRC

* Requesting a slot
The HTTP Upload specify that the client must ask for a "slot" before uploading the file to the server. The slot is a fresh URL that will be enabled for the client to upload the file. The server may give two URLs in one slot query: the uploading URL and the GET URL to share.

The server may limit the file size to upload. 

** jabber-httpupload-parse-slot-answer
#+BEGIN_SRC xml
<iq from='upload.montague.tld'
    id='step_03'
    to='romeo@montague.tld/garden'
    type='result'>
  <slot xmlns='urn:xmpp:http:upload:0'>
    <put url='https://upload.montague.tld/4a771ac1-f0b2-4a4a-9700-f2a26fa2bb67/tr%C3%A8s%20cool.jpg'>
      <header name='Authorization'>Basic Base64String==</header>
      <header name='Cookie'>foo=bar; user=romeo</header>
    </put>
    <get url='https://download.montague.tld/4a771ac1-f0b2-4a4a-9700-f2a26fa2bb67/tr%C3%A8s%20cool.jpg' />
  </slot>
</iq>
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jabber-httpupload-parse-slot-answer (xml-data)
  "Retrieve the slot data from the XML-DATA information.
The XML-DATA is the stanza receive from the Jabber Connection after requesting
the slot for a file.q
The returned list has the PUT URL and the GET URL."
  (list
   (jabber-xml-get-attribute (jabber-xml-path (car iq-a) '(slot put)) 'url)
   (jabber-xml-get-attribute (jabber-xml-path (car iq-a) '(slot get)) 'url)))
#+END_SRC

** WIP jabber-httpupload--request-slot-succesful
#+BEGIN_SRC emacs-lisp
(defun jabber-httpupload--request-slot-succesful (jc xml-data data success-callback)
  "Callback function used when the slot request succeeded.
XML-DATA is the received XML from the server.
DATA is a triple `(filepath content-type JID).
SUCCESS-CALLBACK is a function to call after parsing and requesting the upload.
  It should accept following arguments: JC XML-DATA DATA and the GET and POST
  URLs."
  (let ((urls (jabber-httpupload-parse-slot-answer xml-data)))
    (funcall success-callback jc xml-data data urls)))
#+END_SRC

** jabber-httpupload--request-slot-failed
Maybe this function should be added as lambda inside the jabber-httpupload-request-slot...

#+BEGIN_SRC emacs-lisp
(defun jabber-httpupload--request-slot-failed (jc xml-data data &optional error-callback)
  "Callback function used when the slot request failed.
If ERROR-CALLBACK is defined, no error is thrown and it is called with the
  following parameters: JC XML-DATA DATA"
  (if error-callback
      (funcall error-callback jc xml-data data)
    (error (format "The file %s cannot be uploaded: SLOT rejected. %S"
                   (car data) xml-data))))
#+END_SRC

** WIP jabber-httpupload-request-slot                             :function:
The XML used to request a slot is simmilar as the following:

#+BEGIN_SRC xml
<iq from='romeo@montague.tld/garden'
    id='step_03'
    to='upload.montague.tld'
    type='get'>
  <request xmlns='urn:xmpp:http:upload:0'
    filename='trÃ¨s cool.jpg'
    size='23456'
    content-type='image/jpeg' />
</iq>
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun jabber-httpupload-request-slot (jc filedata success-callback &optional error-callback)
  "Request a slot for HTTP Upload to the server's connection.
JC is an active Jabber Connection.
FILEDATA is a list with (filename size content-type).
SUCCESS-CALLBACK is a function name to call when the slot is received.  Its
  arguments should be: jc xml-data data and URLs.
ERROR-CALLBACK is a function to call on failure.  Its arguments should be:
  jc xml-data."
  (jabber-send-iq jc (cdr (jabber-httpupload-has-support jc)) "get"
                  `(query ((xmlns . "urn:xmpp:http:upload:0")
                           (filename . ,filename)
                           (size . ,size)
                           (content-type . ,content-type)))
                  #'jabber-httpupload--request-slot-succesful
                  (list filename content-type success-callback)
                  #'jabber-httpupload--request-slot-failed
                  (list filename content-type error-callback)))
#+END_SRC

* Uploading the file
Use the HTTP protocol to upload the file to the PUT URL provided by the slot.

The following functions call the upload programs asynchronously.

** jabber-httpupload-upload-file
#+BEGIN_SRC emacs-lisp
(defun jabber-httpupload-upload-file (filepath content-type put-url)
    "Update the given file at FILEPATH to the provided PUT-URL.
The CONTENT-TYPE (MIME type) of the file must match the one provided
to the Jabber Connection with `jabber-httpupload-request-slot'."
    (unless (funcall jabber-httpupload-upload-function filepath content-type put-url)
      (error (concat "The upload function failed to PUT the file to the server. "
                     "Try other function or install the required program"))))
#+END_SRC

** WIP Use CURL to send the file
#+BEGIN_SRC emacs-lisp
(defun jabber-httpupload-put-file-curl (filepath content-type put-url)
  "Use the curl command to put the file at FILEPATH into the PUT-URL.
Send the SIZE and CONTENT-TYPE MIME as headers."
  (let* ((exec-path (executable-find "curl"))
         (cmd (format "%s --upload-file %s -H \"content-type: %s\" %s"
                      exec-path filepath content-type put-url)))
    (when exec-path
      (start-process-shell-command "jabber-httpupload-put-file-curl"
                                   "*jabber-httpupload-put-file-curl*"
                                   cmd))))
#+END_SRC

** TODO Use wget to send the file

* TODO Send the file URL to the client
Prepare the GET URL to send it to an XMPP client throug a Message stanza.

** TODO jabber-httpupload-send-file-url

#+BEGIN_SRC emacs-lisp
(defun jabber-httpupload-send-file-url ()
  "Send the GET URL address to the JID user.")
#+END_SRC


* Chat Buffer
** WIP Send file (complete process)
The following functions add interactive commands to the chat buffer to send the GET URL to the current (or selected) client.

#+BEGIN_SRC emacs-lisp
(defun jabber-httpupload-send-file (jc jid filepath)
  "Send the file at FILEPATH to the user JID.
JC is the Jabber Connection to send the file URL."
  (interactive (list (jabber-read-account)
                     (jabber-read-jid-completing "Send file to: " nil nil nil 'full t)
                     (read-file-name "File to send:")))
  (unless (jabber-httpupload-server-has-support jc)
    (error "The Jabber Connection provided has no HTTP Upload support"))
  (jabber-httpupload-request-slot jc filedata
                                  #'jabber-httpupload--slot-reserved))
#+END_SRC

*** WIP jabber-httpupload--slot-reserved
When the slot is reserved, the HTTP upload should be started.

#+BEGIN_SRC emacs-lisp
(defun jabber-httpupload--slot-reserved (jc xml-data data urls)
  "Callback function used when the slot request succeeded.
JC is the current Jabber Connection.
XML-DATA is the received XML from the server.
DATA is a triple `(filepath content-type JID).
URLs is a tuple `(post-url get-url)."
  (let ((filepath (car data))
        (content-type (nth 1 data))
        (jid (nth 2 data)))
    (message "jabber-httpupload: slot POST and GET URLs: %S" urls)
    (jabber-httpupload-upload-file filepath content-type (car urls))
    (jabber-httpupload-send-file-url jc jid (cdr urls))))
#+END_SRC


** TODO Recording audio and sending
To easy the burden to send an audio message, the following functions allows the user to call a recorder program and send the results through one M-x interactive command.

* Providing the package name
#+BEGIN_SRC emacs-lisp
(provide 'jabber-httpupload)

;;; jabber-httpupload.el ends here
#+END_SRC



* Meta     :noexport:

# ----------------------------------------------------------------------
#+TITLE:  Emacs Jabber HTTP Upload implementation
#+EMAIL:
#+DESCRIPTION: 
#+KEYWORDS: jabber, xmpp, xep-0363, http upload
  
#+STARTUP: inlineimages hidestars content hideblocks entitiespretty
#+STARTUP: indent fninline latexpreview

#+OPTIONS: H:3 num:t toc:t \n:nil @:t ::t |:t ^:{} -:t f:t *:t <:t
#+OPTIONS: TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+OPTIONS: tex:imagemagick

# -- Export
#+LANGUAGE: en
#+LINK_UP: jabber.org
#+LINK_HOME: jabber.org
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport

# -- HTML Export
#+INFOJS_OPT: view:info toc:t ftoc:t ltoc:t mouse:underline buttons:t
#+HTML_LINK_UP: jabber.html
#+HTML_LINK_HOME: jabber.html
#+XSLT:
